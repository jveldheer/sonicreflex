<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sonic Snap – Audio Reaction Trainer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;500;600;700&display=swap');
        
        :root {
            --black: #1A1A1A;
            --yellow: #F5C842;
            --gold: #FFD700;
            --white: #FFFFFF;
            --gray: #B0B0B0;
            --dark-gray: #2A2A2A;
            --border: #3A3A3A;
            --green: #4CAF50;
            --red: #FF5722;
            --blue: #4A90E2;
            --shadow: rgba(0,0,0,0.5);
            --glow: rgba(245, 200, 66, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--black);
            color: var(--white);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            user-select: none;
            line-height: 1.6;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(245, 200, 66, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(245, 200, 66, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            position: relative;
            z-index: 2;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--dark-gray) 0%, #1f1f1f 100%);
            padding: 20px;
            border-bottom: 3px solid var(--yellow);
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 10px 30px var(--shadow);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .logo-wrapper {
            flex-shrink: 0;
            width: 150px;
            height: 84px;
            background: linear-gradient(135deg, var(--yellow), var(--gold));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8em;
            color: var(--black);
            filter: drop-shadow(0 0 25px var(--yellow));
            animation: logoGlow 3s ease-in-out infinite alternate;
        }

        @keyframes logoGlow {
            0% {
                filter: drop-shadow(0 0 20px var(--yellow)) brightness(1.1);
            }
            100% {
                filter: drop-shadow(0 0 40px var(--gold)) drop-shadow(0 0 60px var(--yellow)) brightness(1.25);
            }
        }

        .header-details {
            border-left: 3px solid var(--yellow);
            padding-left: 30px;
        }

        .header-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5em;
            color: var(--yellow);
            letter-spacing: 2px;
            text-shadow: 0 0 25px var(--glow);
        }

        .header-meta {
            color: var(--gray);
            font-size: 1em;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Instructions - Collapsible */
        .instructions {
            background: linear-gradient(135deg, var(--dark-gray) 0%, #222 100%);
            border: 1px solid var(--border);
            border-radius: 15px;
            margin-bottom: 30px;
            position: relative;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }

        .instructions::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--yellow), transparent);
            border-radius: 15px 15px 0 0;
        }

        .instructions-header {
            padding: 20px 30px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .instructions-header:hover {
            background: rgba(245, 200, 66, 0.02);
        }

        .instructions h3 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.2em;
            color: var(--yellow);
            margin: 0;
            letter-spacing: 2px;
            text-shadow: 0 0 20px var(--glow);
        }

        .expand-icon {
            color: var(--yellow);
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }

        .instructions.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .instructions-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0 30px;
        }

        .instructions.expanded .instructions-content {
            max-height: 500px;
            padding: 0 30px 30px 30px;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .instruction-item {
            background: rgba(245, 200, 66, 0.05);
            border-left: 3px solid var(--yellow);
            padding: 15px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .instruction-item:hover {
            background: rgba(245, 200, 66, 0.1);
            transform: translateX(5px);
        }

        .instruction-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .instruction-text strong {
            display: block;
            color: var(--gold);
            margin-bottom: 0.5rem;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2em;
            letter-spacing: 1px;
        }

        .instruction-text span {
            color: var(--gray);
            font-size: 0.95rem;
            line-height: 1.4;
        }

        /* Card */
        .card {
            background: linear-gradient(135deg, var(--dark-gray) 0%, #222 100%);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 20px 50px rgba(0,0,0,0.6), 0 0 20px rgba(245, 200, 66, 0.1);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--yellow), transparent);
            border-radius: 15px 15px 0 0;
        }

        /* Status display */
        .status-container {
            text-align: center;
            margin: 2rem 0;
            position: relative;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .status-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(245, 200, 66, 0.2), transparent);
            animation: statusPulse 3s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes statusPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 0.3; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.3); 
                opacity: 0.6; 
            }
        }

        .status-text {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 3.5rem;
            font-weight: 700;
            text-shadow: 0 0 30px var(--glow);
            position: relative;
            z-index: 1;
            letter-spacing: 2px;
            color: var(--yellow);
        }

        .status-hint {
            font-size: 0.95rem;
            color: var(--gray);
            margin-top: 0.5rem;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* HUD pills */
        .hud {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .hud-pill {
            background: rgba(0,0,0,0.4);
            border: 2px solid var(--yellow);
            border-radius: 12px;
            padding: 0.5rem 1rem;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.3s ease;
        }

        .hud-pill:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(245, 200, 66, 0.2);
        }

        .hud-pill strong {
            color: var(--yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1em;
            letter-spacing: 1px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 100px;
            padding: 1rem 1.5rem;
            background: var(--yellow);
            color: var(--black);
            border: 2px solid var(--yellow);
            border-radius: 8px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.15em;
            letter-spacing: 1.5px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 0 20px var(--glow);
        }

        button:hover {
            background: rgba(245, 200, 66, 0.15);
            border-color: var(--yellow);
            color: var(--white);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: var(--dark-gray);
            border-color: var(--border);
            color: var(--gray);
            box-shadow: none;
        }

        button:focus-visible {
            outline: 3px solid var(--gold);
            outline-offset: 3px;
        }

        /* Settings */
        .setting {
            margin-bottom: 1.5rem;
        }

        .setting label {
            display: block;
            margin-bottom: 0.75rem;
            color: var(--gray);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4em;
            letter-spacing: 1px;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
        }

        .toggle input[type="checkbox"] {
            width: 56px;
            height: 28px;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid var(--border);
        }

        .toggle input[type="checkbox"]:checked {
            background: var(--yellow);
            border-color: var(--yellow);
        }

        .toggle input[type="checkbox"]::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .toggle input[type="checkbox"]:checked::after {
            transform: translateX(28px);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            position: relative;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--yellow);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 10px var(--glow);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 15px var(--glow);
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: var(--yellow);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px var(--glow);
        }

        .slider-value {
            min-width: 100px;
            text-align: center;
            font-weight: 700;
            color: var(--yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Stats cards */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: rgba(0,0,0,0.4);
            border: 2px solid var(--yellow);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(245, 200, 66, 0.2);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--gray);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5em;
            color: var(--yellow);
            text-shadow: 0 0 15px var(--glow);
        }

        /* Leaderboard */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .leaderboard-table th,
        .leaderboard-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .leaderboard-table th {
            font-size: 0.75rem;
            color: var(--gray);
            text-transform: uppercase;
        }

        .leaderboard-table td {
            font-size: 0.9rem;
            color: var(--white);
        }

        .leaderboard-empty {
            text-align: center;
            padding: 2rem;
            color: var(--gray);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--dark-gray);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 400px;
            width: 100%;
        }

        .modal h2 {
            margin-bottom: 1rem;
            color: var(--yellow);
            font-family: 'Bebas Neue', sans-serif;
        }

        .modal input {
            width: 100%;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            color: var(--white);
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .modal input:focus {
            outline: 2px solid var(--yellow);
            outline-offset: 2px;
        }

        .modal-buttons {
            display: flex;
            gap: 0.5rem;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--dark-gray);
            border: 1px solid var(--border);
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            opacity: 0;
            transition: all 0.3s;
            z-index: 999;
            color: var(--white);
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Grade colors */
        .grade-s { color: var(--gold) !important; text-shadow: 0 0 20px var(--glow) !important; }
        .grade-a { color: var(--yellow) !important; }
        .grade-b { color: var(--blue) !important; }
        .grade-c { color: var(--green) !important; }
        .grade-d { color: var(--gray) !important; }
        .grade-fail { color: var(--red) !important; }
        
        /* Countdown style */
        .countdown {
            animation: countdownPulse 1s ease-in-out;
        }
        
        @keyframes countdownPulse {
            0% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
                gap: 20px;
            }
            
            .logo-wrapper {
                width: 120px;
                height: 67px;
            }
            
            .header-details {
                border-left: none;
                border-top: 3px solid var(--yellow);
                padding-left: 0;
                padding-top: 20px;
            }
            
            .header-title {
                font-size: 2em;
            }
            
            .status-text {
                font-size: 2.5rem;
            }
            
            .instructions-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }

        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            animation: fadeIn 0.6s ease-out;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo-wrapper">
                SONIC SNAP
            </div>
            <div class="header-details">
                <div class="header-title">SONIC SNAP</div>
                <div class="header-meta">Audio Reaction Trainer • Test Your Elite Gaming Reflexes</div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Collapsible Instructions -->
        <div class="instructions" id="instructions">
            <div class="instructions-header" onclick="toggleInstructions()">
                <h3>HOW TO PLAY</h3>
                <span class="expand-icon" id="expandIcon">▼</span>
            </div>
            <div class="instructions-content">
                <div class="instructions-grid">
                    <div class="instruction-item">
                        <div class="instruction-icon">📱</div>
                        <div class="instruction-text">
                            <strong>MOBILE PLAYERS</strong>
                            <span>Tap anywhere on screen when you hear the whistle (GO signal). The screen is your button - react fast but don't jump the gun!</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <div class="instruction-icon">💻</div>
                        <div class="instruction-text">
                            <strong>DESKTOP WARRIORS</strong>
                            <span>Smash that SPACE bar or click when you hear the whistle. Timing is everything - too early = penalty!</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <div class="instruction-icon">🔊</div>
                        <div class="instruction-text">
                            <strong>AUDIO SIGNALS</strong>
                            <span>WHISTLE = GO NOW! In hard mode, ignore cadence calls (ON ONE, ON TWO, etc.) - only react to the whistle!</span>
                        </div>
                    </div>
                    <div class="instruction-item">
                        <div class="instruction-icon">🏆</div>
                        <div class="instruction-text">
                            <strong>SCORING SYSTEM</strong>
                            <span>Faster = more points. Streaks multiply score. Hard mode & crowd noise = bonus points!</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">            
            <div class="status-container">
                <div class="status-ring"></div>
                <div class="status-text" id="statusText">TAP START</div>
                <div class="status-hint" id="statusHint">Ready to test your reflexes?</div>
            </div>

            <div class="hud" id="hud">
                <div class="hud-pill">Round <strong id="hudRound">0/0</strong></div>
                <div class="hud-pill">Score <strong id="hudScore">0</strong></div>
                <div class="hud-pill">Best <strong id="hudBest">—</strong></div>
                <div class="hud-pill">Avg <strong id="hudAvg">—</strong></div>
                <div class="hud-pill">Streak 🔥 <strong id="hudStreak">0</strong></div>
            </div>

            <div class="controls">
                <button id="startBtn">START</button>
                <button id="stopBtn" disabled>STOP</button>
            </div>
        </div>

        <div class="card">
            <div class="setting">
                <div class="toggle">
                    <input type="checkbox" id="hardMode">
                    <label for="hardMode">Hard Mode (Cadence Calls)</label>
                </div>
            </div>

            <div class="setting">
                <div class="toggle">
                    <input type="checkbox" id="crowdNoise">
                    <label for="crowdNoise">Crowd Noise</label>
                </div>
            </div>

            <div class="setting" id="crowdLevelSetting" style="display: none;">
                <label for="crowdLevel">Crowd Intensity</label>
                <div class="slider-container">
                    <input type="range" id="crowdLevel" min="1" max="5" value="3">
                    <div class="slider-value" id="crowdLevelValue">Medium</div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Last</div>
                    <div class="stat-value" id="statLast">—</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">False Starts</div>
                    <div class="stat-value" id="statFalseStarts">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Cadence Hits</div>
                    <div class="stat-value" id="statNoGoHits">0</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 style="color: var(--yellow); font-family: 'Bebas Neue', sans-serif; font-size: 2em; margin-bottom: 1rem;">
                <span id="leaderboardTitle">Normal Mode Leaderboard</span>
            </h2>
            <div class="controls">
                <button id="toggleLeaderboard" onclick="toggleLeaderboardMode()">View Hard Mode</button>
            </div>
            <div id="leaderboardContent"></div>
        </div>
    </div>

    <div class="modal" id="nameModal">
        <div class="modal-content">
            <h2>Save Score</h2>
            <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
            <div class="modal-buttons">
                <button id="saveNameBtn">Save</button>
                <button id="cancelNameBtn">Cancel</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast" role="alert" aria-live="polite"></div>

    <script>
        // Game state machine
        const GameState = {
            IDLE: 'idle',
            WAITING: 'waiting',
            CUED_GO: 'cuedGo',
            CUED_BAIT: 'cuedBait',
            COOLDOWN: 'cooldown',
            PAUSED: 'paused',
            FINISHED: 'finished'
        };

        // Audio context and utilities with crowd noise
        class AudioManager {
            constructor() {
                this.context = null;
                this.masterGain = null;
                this.crowdGain = null;
                this.crowdSource = null;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;
                
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.context = new AudioContext();
                
                this.masterGain = this.context.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.context.destination);
                
                // Setup crowd noise gain node
                this.crowdGain = this.context.createGain();
                this.crowdGain.gain.value = 0;
                this.crowdGain.connect(this.context.destination);
                
                if (this.context.state === 'suspended') {
                    await this.context.resume();
                }
                
                this.playTone(1, 0.001, 0.01);
                
                this.initialized = true;
            }

            playTone(frequency, volume = 0.3, duration = 0.1) {
                if (!this.initialized) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                const now = this.context.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                oscillator.start(now);
                oscillator.stop(now + duration + 0.05);
            }

            playGoTone() {
                // Play a whistle sound for GO signal
                if (!this.initialized) return;
                
                const duration = 0.4;
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                // Create whistle effect with frequency sweep
                const now = this.context.currentTime;
                oscillator.frequency.setValueAtTime(2000, now);
                oscillator.frequency.exponentialRampToValueAtTime(2400, now + duration * 0.3);
                oscillator.frequency.exponentialRampToValueAtTime(2200, now + duration);
                
                // Add vibrato for realism
                const vibrato = this.context.createOscillator();
                const vibratoGain = this.context.createGain();
                vibrato.frequency.value = 6;
                vibratoGain.gain.value = 50;
                vibrato.connect(vibratoGain);
                vibratoGain.connect(oscillator.frequency);
                vibrato.start(now);
                vibrato.stop(now + duration);
                
                oscillator.type = 'sine';
                
                // Envelope for whistle
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.3, now + duration * 0.7);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                oscillator.start(now);
                oscillator.stop(now + duration + 0.1);
            }

            playBaitTone() {
                // Fallback synthesized tone for cadence calls
                this.playTone(440, 0.3, 0.2);
            }

            startCrowdNoise(level) {
                if (!this.initialized) return;
                
                // Create brown noise for crowd simulation
                const bufferSize = 2 * this.context.sampleRate;
                const noiseBuffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                // Generate brown noise (more realistic crowd sound)
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    output[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = output[i];
                    output[i] *= 3.5;
                }
                
                // Create and configure the noise source
                this.crowdSource = this.context.createBufferSource();
                this.crowdSource.buffer = noiseBuffer;
                this.crowdSource.loop = true;
                
                // Apply filter to make it sound more like crowd
                const filter = this.context.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                
                const filter2 = this.context.createBiquadFilter();
                filter2.type = 'highpass';
                filter2.frequency.value = 100;
                
                // Connect the chain
                this.crowdSource.connect(filter);
                filter.connect(filter2);
                filter2.connect(this.crowdGain);
                
                // Set volume based on level (1-5)
                const volumeLevels = {
                    1: 0.05,  // Quiet
                    2: 0.1,   // Low
                    3: 0.15,  // Medium
                    4: 0.25,  // Loud
                    5: 0.35   // Very Loud
                };
                
                this.crowdGain.gain.setValueAtTime(volumeLevels[level] || 0.15, this.context.currentTime);
                
                this.crowdSource.start();
            }

            stopCrowdNoise() {
                if (this.crowdSource) {
                    this.crowdSource.stop();
                    this.crowdSource = null;
                }
                if (this.crowdGain) {
                    this.crowdGain.gain.setValueAtTime(0, this.context.currentTime);
                }
            }
        }

        // Main game class - stores data in memory instead of localStorage
        class SonicSnap {
            constructor() {
                this.audio = new AudioManager();
                this.state = GameState.IDLE;
                this.currentRound = 0;
                this.totalRounds = 10;
                this.score = 0;
                this.streak = 0;
                this.bestMs = null;
                this.validRTs = [];
                this.lastRT = null;
                this.falseStarts = 0;
                this.noGoHits = 0;
                this.cueStartTime = null;
                this.waitTimeout = null;
                this.cueTimeout = null;
                this.cooldownTimeout = null;
                this.hasReacted = false;
                
                this.hardMode = false;
                this.crowdNoise = false;
                this.crowdLevel = 3;
                this.pace = 3;
                this.viewingHardLeaderboard = false;
                
                // Cadence audio configuration with GitHub URLs
                this.cadenceAudios = {};
                this.preloadedCadences = {};
                this.currentCadence = null;
                this.goWindowStart = null;
                
                this.crowdLevelLabels = {
                    1: 'Quiet',
                    2: 'Low',
                    3: 'Medium',
                    4: 'Loud',
                    5: 'Very Loud'
                };
                
                this.paceProfiles = {
                    1: { min: 1200, max: 2600, label: 'Chill' },
                    2: { min: 1000, max: 2200, label: 'Smooth' },
                    3: { min: 800, max: 2000, label: 'Locked' },
                    4: { min: 650, max: 1700, label: 'Sweaty' },
                    5: { min: 500, max: 1500, label: 'Beast' }
                };
                
                this.BAIT_CHANCE = 0.28;
                this.BAIT_PASS_WINDOW = 2400;
                this.COOLDOWN_MS = 650;
                this.MIN_VALID_RT = 100;
                
                // In-memory storage for settings and leaderboard
                this.savedSettings = {
                    hardMode: false,
                    crowdNoise: false,
                    crowdLevel: 3
                };
                
                this.leaderboards = {
                    normal: [],
                    hard: []
                };
                
                this.playerName = '';
                
                this.bindEvents();
                this.loadSettings();
                this.updateLeaderboard();
            }

            bindEvents() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                
                document.getElementById('hardMode').addEventListener('change', (e) => {
                    this.hardMode = e.target.checked;
                    this.saveSettings();
                    this.viewingHardLeaderboard = this.hardMode;
                    this.updateLeaderboard();
                    this.updateLeaderboardTitle();
                });
                
                document.getElementById('crowdNoise').addEventListener('change', (e) => {
                    this.crowdNoise = e.target.checked;
                    const levelSetting = document.getElementById('crowdLevelSetting');
                    if (this.crowdNoise) {
                        levelSetting.style.display = 'block';
                    } else {
                        levelSetting.style.display = 'none';
                    }
                    this.saveSettings();
                });
                
                document.getElementById('crowdLevel').addEventListener('input', (e) => {
                    this.crowdLevel = parseInt(e.target.value);
                    document.getElementById('crowdLevelValue').textContent = this.crowdLevelLabels[this.crowdLevel];
                    this.saveSettings();
                });
                
                document.addEventListener('pointerdown', (e) => {
                    if (e.target.closest('button, input, label')) return;
                    this.react();
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.react();
                    }
                });
                
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.state !== GameState.IDLE && this.state !== GameState.FINISHED) {
                        this.pause();
                    } else if (!document.hidden && this.state === GameState.PAUSED) {
                        this.resume();
                    }
                });
                
                document.getElementById('saveNameBtn').addEventListener('click', () => this.saveScore());
                document.getElementById('cancelNameBtn').addEventListener('click', () => this.closeNameModal());
                document.getElementById('playerName').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') this.saveScore();
                });
            }

            loadSettings() {
                // Use in-memory settings instead of localStorage
                this.hardMode = this.savedSettings.hardMode;
                this.crowdNoise = this.savedSettings.crowdNoise;
                this.crowdLevel = this.savedSettings.crowdLevel;
                
                document.getElementById('hardMode').checked = this.hardMode;
                document.getElementById('crowdNoise').checked = this.crowdNoise;
                document.getElementById('crowdLevel').value = this.crowdLevel;
                document.getElementById('crowdLevelValue').textContent = this.crowdLevelLabels[this.crowdLevel];
                
                if (this.crowdNoise) {
                    document.getElementById('crowdLevelSetting').style.display = 'block';
                }
                
                this.viewingHardLeaderboard = this.hardMode;
                this.updateLeaderboardTitle();
            }

            saveSettings() {
                // Save to in-memory object instead of localStorage
                this.savedSettings = {
                    hardMode: this.hardMode,
                    crowdNoise: this.crowdNoise,
                    crowdLevel: this.crowdLevel
                };
            }

            async start() {
                const instructions = document.getElementById('instructions');
                instructions.classList.remove('expanded');
                
                await this.audio.init();
                
                // Start crowd noise if enabled
                if (this.crowdNoise) {
                    this.audio.startCrowdNoise(this.crowdLevel);
                }
                
                this.state = GameState.WAITING;
                this.currentRound = 0;
                this.score = 0;
                this.streak = 0;
                this.bestMs = null;
                this.validRTs = [];
                this.lastRT = null;
                this.falseStarts = 0;
                this.noGoHits = 0;
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('hardMode').disabled = true;
                document.getElementById('crowdNoise').disabled = true;
                document.getElementById('crowdLevel').disabled = true;
                
                this.updateHUD();
                this.nextRound();
            }

            stop() {
                this.clearTimeouts();
                this.state = GameState.IDLE;
                
                // Stop crowd noise
                this.audio.stopCrowdNoise();
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('hardMode').disabled = false;
                document.getElementById('crowdNoise').disabled = false;
                document.getElementById('crowdLevel').disabled = false;
                
                this.updateStatus('Stopped', '');
            }

            pause() {
                if (this.state === GameState.PAUSED) return;
                
                this.clearTimeouts();
                this.previousState = this.state;
                this.state = GameState.PAUSED;
                this.updateStatus('Paused', '');
            }

            resume() {
                if (this.state !== GameState.PAUSED) return;
                
                this.state = GameState.WAITING;
                this.scheduleNextCue();
            }

            nextRound() {
                if (this.currentRound >= this.totalRounds) {
                    this.finish();
                    return;
                }
                
                this.currentRound++;
                this.hasReacted = false;
                this.updateHUD();
                this.scheduleNextCue();
            }

            scheduleNextCue() {
                this.state = GameState.WAITING;
                this.updateStatus('LISTEN…', 'Wait for the whistle. Don\'t jump early.');
                
                const profile = this.paceProfiles[this.pace];
                const delay = profile.min + Math.random() * (profile.max - profile.min);
                
                const isBait = this.hardMode && Math.random() < this.BAIT_CHANCE;
                
                this.waitTimeout = setTimeout(() => {
                    if (isBait) {
                        this.cueBait();
                    } else {
                        this.cueGo();
                    }
                }, delay);
            }

            cueGo() {
                this.state = GameState.CUED_GO;
                this.cueStartTime = performance.now();
                this.audio.playGoTone();
                
                this.updateStatus('GO!', 'React now!', 'grade-a');
                
                this.cueTimeout = setTimeout(() => {
                    if (!this.hasReacted) {
                        this.handleMissedGo();
                    }
                }, 2000);
            }

            cueBait() {
                // Select random cadence
                this.currentCadence = this.cadenceNames[Math.floor(Math.random() * this.cadenceNames.length)];
                
                // Show cadence name for 1 second before playing
                this.updateStatus(this.currentCadence, 'Cadence call coming...', 'grade-b');
                
                setTimeout(() => {
                    this.state = GameState.CUED_BAIT;
                    this.cueStartTime = performance.now();
                    
                    // Play synthesized sound
                    this.audio.playBaitTone();
                    
                    this.updateStatus('IGNORE', 'Don\'t react to cadence calls!', 'grade-b');
                    
                    // Extended pass window
                    this.cueTimeout = setTimeout(() => {
                        if (!this.hasReacted) {
                            this.handleBaitPass();
                        }
                    }, this.BAIT_PASS_WINDOW);
                }, 1000);
            }

            react() {
                if (this.hasReacted || this.state === GameState.COOLDOWN || 
                    this.state === GameState.IDLE || this.state === GameState.FINISHED || 
                    this.state === GameState.PAUSED) {
                    return;
                }
                
                this.hasReacted = true;
                this.clearTimeouts();
                
                switch (this.state) {
                    case GameState.WAITING:
                        this.handleFalseStart();
                        break;
                    case GameState.CUED_GO:
                        this.handleGoReaction();
                        break;
                    case GameState.CUED_BAIT:
                        this.handleNoGoHit();
                        break;
                }
            }

            handleGoReaction() {
                const rt = performance.now() - this.cueStartTime;
                
                if (rt < this.MIN_VALID_RT) {
                    this.handleTooEarly();
                    return;
                }
                
                this.lastRT = Math.round(rt);
                this.validRTs.push(this.lastRT);
                
                if (this.bestMs === null || this.lastRT < this.bestMs) {
                    this.bestMs = this.lastRT;
                }
                
                const points = this.calculatePoints(this.lastRT);
                this.score += points;
                this.streak++;
                
                const grade = this.getGrade(this.lastRT);
                
                this.updateStatus(
                    `${this.lastRT}ms ${grade.emoji}`,
                    `${grade.label} • +${points} points`,
                    grade.class
                );
                
                this.vibrate(20);
                
                this.updateHUD();
                this.startCooldown();
            }

            handleFalseStart() {
                this.falseStarts++;
                this.streak = 0;
                this.score = Math.max(0, this.score - 120);
                
                this.updateStatus('FALSE START', 'Reacted before the whistle!', 'grade-fail');
                this.vibrate([50, 30, 50]);
                
                this.updateHUD();
                this.startCooldown();
            }

            handleTooEarly() {
                this.falseStarts++;
                this.streak = 0;
                this.score = Math.max(0, this.score - 100);
                
                this.updateStatus('TOO EARLY', 'Under 100ms = anticipation.', 'grade-fail');
                this.vibrate([50, 30, 50]);
                
                this.updateHUD();
                this.startCooldown();
            }

            handleNoGoHit() {
                this.noGoHits++;
                this.streak = 0;
                this.score = Math.max(0, this.score - 180);
                
                this.updateStatus('TOO EARLY!', 'Wait for the whistle at the END of the cadence!', 'grade-fail');
                this.vibrate([100, 50, 100]);
                
                this.updateHUD();
                this.startCooldown();
            }

            handleMissedGo() {
                this.streak = 0;
                
                this.updateStatus('MISSED', 'React faster next time', 'grade-d');
                
                this.updateHUD();
                this.startCooldown();
            }

            startCooldown() {
                this.state = GameState.COOLDOWN;
                
                this.cooldownTimeout = setTimeout(() => {
                    this.nextRound();
                }, this.COOLDOWN_MS);
            }

            finish() {
                this.state = GameState.FINISHED;
                
                // Stop crowd noise
                this.audio.stopCrowdNoise();
                
                const avgMs = this.validRTs.length > 0 
                    ? Math.round(this.validRTs.reduce((a, b) => a + b, 0) / this.validRTs.length)
                    : null;
                
                const isTop10 = this.checkIfTop10(this.score);
                
                if (isTop10) {
                    this.updateStatus(
                        'TOP 10!',
                        avgMs ? `Avg ${avgMs}ms • Enter your name for the leaderboard!` : 'Enter your name for the leaderboard!'
                    );
                    
                    setTimeout(() => {
                        this.openNameModal();
                    }, 1000);
                } else {
                    this.updateStatus(
                        'Done',
                        avgMs ? `Avg ${avgMs}ms • Score: ${this.score}` : `Score: ${this.score}`
                    );
                    
                    this.showToast('Session complete. Try again to make the leaderboard!');
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('hardMode').disabled = false;
                document.getElementById('crowdNoise').disabled = false;
                document.getElementById('crowdLevel').disabled = false;
            }

            checkIfTop10(score) {
                const leaderboard = this.hardMode ? this.leaderboards.hard : this.leaderboards.normal;
                
                if (leaderboard.length < 10) {
                    return true;
                }
                
                const lowestScore = leaderboard[leaderboard.length - 1].score;
                return score > lowestScore;
            }

            calculatePoints(rt) {
                let points = Math.max(0, 550 - rt);
                
                if (rt < 180) {
                    points += 75 + 50;
                } else if (rt < 230) {
                    points += 75;
                }
                
                // Streak multipliers
                if (this.streak >= 6) {
                    points *= 1.25;
                } else if (this.streak >= 3) {
                    points *= 1.15;
                }
                
                // Hard mode multiplier
                if (this.hardMode) {
                    points *= 1.3;
                }
                
                // Crowd noise multiplier based on level
                if (this.crowdNoise) {
                    const crowdMultipliers = {
                        1: 1.05,
                        2: 1.1,
                        3: 1.15,
                        4: 1.25,
                        5: 1.4
                    };
                    points *= crowdMultipliers[this.crowdLevel] || 1.15;
                }
                
                return Math.round(points);
            }

            getGrade(rt) {
                if (rt < 180) return { label: 'S', emoji: '⚡', class: 'grade-s' };
                if (rt < 230) return { label: 'A', emoji: '🔥', class: 'grade-a' };
                if (rt < 280) return { label: 'B', emoji: '💥', class: 'grade-b' };
                if (rt < 350) return { label: 'C', emoji: '✨', class: 'grade-c' };
                return { label: 'D', emoji: '🙂', class: 'grade-d' };
            }

            updateStatus(text, hint = '', className = '') {
                const statusText = document.getElementById('statusText');
                statusText.textContent = text.toUpperCase();
                statusText.className = `status-text ${className}`;
                document.getElementById('statusHint').textContent = hint;
            }

            updateHUD() {
                document.getElementById('hudRound').textContent = `${this.currentRound}/${this.totalRounds}`;
                document.getElementById('hudScore').textContent = this.score;
                document.getElementById('hudBest').textContent = this.bestMs ? `${this.bestMs}ms` : '—';
                
                const avgMs = this.validRTs.length > 0 
                    ? Math.round(this.validRTs.reduce((a, b) => a + b, 0) / this.validRTs.length)
                    : null;
                document.getElementById('hudAvg').textContent = avgMs ? `${avgMs}ms` : '—';
                
                document.getElementById('hudStreak').textContent = this.streak;
                
                document.getElementById('statLast').textContent = this.lastRT ? `${this.lastRT}ms` : '—';
                document.getElementById('statFalseStarts').textContent = this.falseStarts;
                document.getElementById('statNoGoHits').textContent = this.noGoHits;
            }

            clearTimeouts() {
                clearTimeout(this.waitTimeout);
                clearTimeout(this.cueTimeout);
                clearTimeout(this.cooldownTimeout);
            }

            vibrate(pattern) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(pattern);
                }
            }

            openNameModal() {
                const modal = document.getElementById('nameModal');
                modal.classList.add('active');
                
                if (this.playerName) {
                    document.getElementById('playerName').value = this.playerName;
                }
                
                document.getElementById('playerName').focus();
            }

            closeNameModal() {
                document.getElementById('nameModal').classList.remove('active');
            }

            saveScore() {
                const name = document.getElementById('playerName').value.trim();
                if (!name) {
                    this.showToast('Please enter a name');
                    return;
                }
                
                this.playerName = name;
                
                const avgMs = this.validRTs.length > 0 
                    ? Math.round(this.validRTs.reduce((a, b) => a + b, 0) / this.validRTs.length)
                    : null;
                
                const entry = {
                    name,
                    score: this.score,
                    best: this.bestMs,
                    avg: avgMs,
                    mode: this.paceProfiles[this.pace].label,
                    hard: this.hardMode,
                    crowd: this.crowdNoise ? this.crowdLevel : 0,
                    rounds: this.totalRounds,
                    when: Date.now()
                };
                
                const leaderboard = this.hardMode ? this.leaderboards.hard : this.leaderboards.normal;
                
                leaderboard.push(entry);
                leaderboard.sort((a, b) => b.score - a.score);
                
                // Keep only top 10
                if (this.hardMode) {
                    this.leaderboards.hard = leaderboard.slice(0, 10);
                } else {
                    this.leaderboards.normal = leaderboard.slice(0, 10);
                }
                
                this.closeNameModal();
                this.updateLeaderboard();
                this.showToast(`Score saved to ${this.hardMode ? 'Hard Mode' : 'Normal Mode'} leaderboard!`);
            }

            updateLeaderboard() {
                const content = document.getElementById('leaderboardContent');
                const leaderboard = this.viewingHardLeaderboard ? this.leaderboards.hard : this.leaderboards.normal;
                
                if (leaderboard.length === 0) {
                    content.innerHTML = '<div class="leaderboard-empty">No scores yet. Be the first!</div>';
                    return;
                }
                
                let html = '<table class="leaderboard-table"><thead><tr>';
                html += '<th>#</th><th>Name</th><th>Score</th><th>Best</th><th>Avg</th><th>Crowd</th><th>Date</th>';
                html += '</tr></thead><tbody>';
                
                leaderboard.forEach((entry, i) => {
                    const date = new Date(entry.when).toLocaleDateString();
                    const crowdText = entry.crowd ? `L${entry.crowd}` : '—';
                    
                    html += '<tr>';
                    html += `<td>${i + 1}</td>`;
                    html += `<td>${this.escapeHtml(entry.name)}</td>`;
                    html += `<td>${entry.score}</td>`;
                    html += `<td>${entry.best ? entry.best + 'ms' : '—'}</td>`;
                    html += `<td>${entry.avg ? entry.avg + 'ms' : '—'}</td>`;
                    html += `<td>${crowdText}</td>`;
                    html += `<td style="font-size: 0.75rem; color: var(--gray)">${date}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                content.innerHTML = html;
            }

            updateLeaderboardTitle() {
                const title = document.getElementById('leaderboardTitle');
                const button = document.getElementById('toggleLeaderboard');
                
                if (this.viewingHardLeaderboard) {
                    title.textContent = 'Hard Mode Leaderboard';
                    button.textContent = 'View Normal Mode';
                } else {
                    title.textContent = 'Normal Mode Leaderboard';
                    button.textContent = 'View Hard Mode';
                }
            }

            showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Toggle instructions function
        function toggleInstructions() {
            const instructions = document.getElementById('instructions');
            instructions.classList.toggle('expanded');
        }

        // Toggle between normal and hard mode leaderboards
        function toggleLeaderboardMode() {
            window.game.viewingHardLeaderboard = !window.game.viewingHardLeaderboard;
            window.game.updateLeaderboard();
            window.game.updateLeaderboardTitle();
        }

        // Initialize game when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new SonicSnap();
        });
    </script>
</body>
</html>
